import { Entity } from "../../core/util/Entity";
import { Component } from "../../core/render/Component";
import { Color } from "../../core/util/Color";
import { Gradient } from "../../core/render/gradients/Gradient";
import { Percent } from "../../core/util/Percent";
import { Template } from "../../core/util/Template";
import { ListData } from "../../core/util/Data";
import * as $type from "../../core/util/Type";
import * as $array from "../../core/util/Array";
import * as $object from "../../core/util/Object";
/**
 * Provides functionality to serialize charts or individual elements into simple
 * objects or JSON.
 *
 * @see {@link https://www.amcharts.com/docs/v5/concepts/serializing/} for more info
 * @since 5.3.0
 */
export class Serializer extends Entity {
    constructor() {
        super(...arguments);
        this._refs = {};
    }
    /**
     * Serializes target object into a simple object or JSON string.
     *
     * @param   source      Target object
     * @param   depth       Current depth
     * @param   full        Serialize object in full (ignoring maxDepth)
     * @param   forceParse  If true, will add __parse to serialized objects
     * @return              Serialized data
     */
    serialize(source, depth = 0, full = false, forceParse = false) {
        if (depth > this.get("maxDepth", 2)) {
            return undefined;
        }
        if (source === false || source === true) {
            return source;
        }
        if ($type.isArray(source)) {
            const res = [];
            $array.each(source, (arrval) => {
                res.push(this.serialize(arrval, depth, full, forceParse));
            });
            return res;
        }
        else if (source instanceof ListData) {
            const res = [];
            $array.each(source.values, (arrval) => {
                res.push(this.serialize(arrval, depth, full, forceParse));
            });
            return res;
        }
        const res = {};
        const am5object = source instanceof Entity || source instanceof Template || source instanceof Color || source instanceof Percent ? true : false;
        // Process settings
        const fullSettings = this.get("fullSettings", []);
        if (source instanceof Entity) {
            res.type = source.className;
            let settings = this._filterSettings($object.keys(source._settings));
            // Include only user settings
            settings = settings.filter((value) => {
                return source.isUserSetting(value);
            });
            if (settings.length) {
                res.settings = {};
                $array.each(settings, (setting) => {
                    const settingValue = source.get(setting);
                    if (settingValue !== undefined) {
                        res.settings[setting] = this.serialize(settingValue, depth + 1, full || fullSettings.indexOf(setting) !== -1);
                        if (source instanceof Gradient && setting === "stops") {
                            res.settings[setting] = this.serialize(settingValue, 0, true);
                        }
                    }
                });
            }
            this._processAdapters(source, res);
            this._processStates(source, res);
        }
        else if (source instanceof Template) {
            res.type = "Template";
            let settings = this._filterSettings($object.keys(source._settings));
            if (settings.length) {
                res.settings = {};
                $array.each(settings, (setting) => {
                    if (source._settings[setting] !== undefined) {
                        res.settings[setting] = this.serialize(source.get(setting), depth + 1, fullSettings.indexOf(setting) !== -1);
                    }
                });
            }
            this._processAdapters(source, res);
            this._processStates(source, res);
            return res;
        }
        // Data
        if (source instanceof Component) {
            if (source.data.length && (this.get("excludeProperties") || []).indexOf("data") === -1) {
                res.properties = {
                    data: this.serialize(source.data.values, depth, true)
                };
            }
        }
        // Process the rest
        if (source instanceof Color) {
            return {
                type: "Color",
                value: source.toCSSHex()
            };
        }
        else if (source instanceof Percent) {
            return {
                type: "Percent",
                value: source.percent
            };
        }
        else if ($type.isString(source)) {
            return this._escapeRefs(source);
        }
        else if ($type.isNumber(source)) {
            return source;
        }
        else if ($type.isObject(source)) {
            // TODO
            if (full && !am5object) {
                const excludeProperties = this.get("excludeProperties", []);
                $object.each(source, (key, value) => {
                    if (excludeProperties.indexOf(key) === -1 && value !== undefined) {
                        res[key] = this.serialize(value, depth + 1, full, forceParse);
                    }
                });
                if (forceParse) {
                    // Add only if there are objects
                    $object.each(res, (_key, value) => {
                        if ($type.isObject(value)) {
                            res.__parse = true;
                        }
                    });
                }
            }
            else if (am5object) {
                const includeProperties = this.get("includeProperties", []);
                $array.each(includeProperties, (key) => {
                    const value = source[key];
                    if (value !== undefined) {
                        if (res.properties === undefined) {
                            res.properties = {};
                        }
                        res.properties[key] = this.serialize(value, depth + 1, full, forceParse);
                    }
                });
            }
        }
        if (depth == 0 && $object.keys(this._refs).length) {
            res.refs = this._refs;
        }
        return res;
    }
    _processAdapters(source, res) {
        if (this.get("includeAdapters", false)) {
            const asString = this.get("functionsAs", "string") == "string";
            const callbacks = source.adapters._callbacks;
            if (Object.keys(callbacks).length > 0) {
                res.adapters = [];
                $object.each(callbacks, (key, callbackList) => {
                    callbackList.forEach((callback) => {
                        res.adapters.push({
                            key: key,
                            callback: asString ? callback.toString() : callback
                        });
                    });
                });
            }
        }
    }
    _processStates(source, res) {
        if (this.get("includeStates", false)) {
            const states = source.states._states;
            if (Object.keys(states).length > 0) {
                res.states = [];
                $object.each(states, (key, state) => {
                    if (Object.keys(state._settings).length > 0) {
                        res.states.push({
                            key: key,
                            settings: this.serialize(state._settings, 0, true)
                        });
                    }
                });
            }
        }
    }
    _filterSettings(settings) {
        const includeSettings = this.get("includeSettings", []);
        const excludeSettings = this.get("excludeSettings", []);
        if (includeSettings.length) {
            settings = includeSettings;
        }
        else if (excludeSettings.length) {
            settings = settings.filter((value) => {
                return excludeSettings.indexOf(value) === -1;
            });
        }
        return settings;
    }
    _escapeRefs(text) {
        return text.replace(/^#/, '##').replace(/^@/, '@@');
    }
}
Serializer.className = "Serializer";
Serializer.classNames = Entity.classNames.concat([Serializer.className]);
//# sourceMappingURL=Serializer.js.map