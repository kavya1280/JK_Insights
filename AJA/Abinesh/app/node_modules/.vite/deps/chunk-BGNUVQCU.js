import {
  Container,
  Graphics,
  Label,
  Rectangle,
  addEventListener,
  color,
  fitToRange,
  getEventKey,
  isLocalEvent,
  mergeTags,
  relativeToValue,
  supports
} from "./chunk-VC4LUFSW.js";
import {
  Percent
} from "./chunk-JY4IRPBG.js";
import {
  MultiDisposer,
  each,
  isNumber
} from "./chunk-C2GNBQHD.js";

// node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js
var RoundedRectangle = class extends Rectangle {
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) {
      this._clear = true;
    }
  }
  _draw() {
    let width = this.width();
    let height = this.height();
    let wSign = width / Math.abs(width);
    let hSign = height / Math.abs(height);
    let x = 0;
    let y = 0;
    const strokeWidth = this.get("strokeWidth", 0);
    if (this.get("containStroke", false)) {
      width -= wSign * strokeWidth;
      height -= hSign * strokeWidth;
      x += wSign * strokeWidth / 2;
      y += hSign * strokeWidth / 2;
    }
    let w = width;
    let h = height;
    if (isNumber(w) && isNumber(h)) {
      let minSide = Math.min(w, h) / 2;
      let crtl = relativeToValue(this.get("cornerRadiusTL", 8), minSide);
      let crtr = relativeToValue(this.get("cornerRadiusTR", 8), minSide);
      let crbr = relativeToValue(this.get("cornerRadiusBR", 8), minSide);
      let crbl = relativeToValue(this.get("cornerRadiusBL", 8), minSide);
      let maxcr = Math.min(Math.abs(w / 2), Math.abs(h / 2));
      crtl = fitToRange(crtl, 0, maxcr);
      crtr = fitToRange(crtr, 0, maxcr);
      crbr = fitToRange(crbr, 0, maxcr);
      crbl = fitToRange(crbl, 0, maxcr);
      const display = this._display;
      display.moveTo(x + crtl * wSign, y);
      display.lineTo(x + w - crtr * wSign, y);
      if (crtr > 0) {
        display.arcTo(x + w, y, x + w, y + crtr * hSign, crtr);
      }
      display.lineTo(x + w, y + h - crbr * hSign);
      if (crbr > 0) {
        display.arcTo(x + w, y + h, x + w - crbr * wSign, y + h, crbr);
      }
      display.lineTo(x + crbl * wSign, y + h);
      if (crbl > 0) {
        display.arcTo(x, y + h, x, y + h - crbl * hSign, crbl);
      }
      display.lineTo(x, y + crtl * hSign);
      if (crtl > 0) {
        display.arcTo(x, y, x + crtl * wSign, y, crtl);
      }
      display.closePath();
    }
  }
};
RoundedRectangle.className = "RoundedRectangle";
RoundedRectangle.classNames = Rectangle.classNames.concat([RoundedRectangle.className]);

// node_modules/@amcharts/amcharts5/.internal/core/render/Button.js
var Button = class extends Container {
  _afterNew() {
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["button"]);
    super._afterNew();
    if (!this._settings.background) {
      this.set("background", RoundedRectangle.new(this._root, {
        themeTags: mergeTags(this._settings.themeTags, ["background"])
      }));
    }
    this.setPrivate("trustBounds", true);
  }
  _prepareChildren() {
    super._prepareChildren();
    if (this.isDirty("icon")) {
      const previous = this._prevSettings.icon;
      const icon = this.get("icon");
      if (icon !== previous) {
        this._disposeProperty("icon");
        if (previous) {
          previous.dispose();
        }
        if (icon) {
          this.children.push(icon);
        }
        this._prevSettings.icon = icon;
      }
    }
    if (this.isDirty("label")) {
      const previous = this._prevSettings.label;
      const label = this.get("label");
      if (label !== previous) {
        this._disposeProperty("label");
        if (previous) {
          previous.dispose();
        }
        if (label) {
          this.children.push(label);
        }
        this._prevSettings.label = label;
      }
    }
  }
};
Button.className = "Button";
Button.classNames = Container.classNames.concat([Button.className]);

// node_modules/@amcharts/amcharts5/.internal/core/render/Scrollbar.js
var Scrollbar = class extends Container {
  constructor() {
    super(...arguments);
    this.thumb = this._makeThumb();
    this.startGrip = this._makeButton();
    this.endGrip = this._makeButton();
    this._thumbBusy = false;
    this._startDown = false;
    this._endDown = false;
    this._thumbDown = false;
  }
  _addOrientationClass() {
    this._settings.themeTags = mergeTags(this._settings.themeTags, ["scrollbar", this._settings.orientation]);
    if (!this._settings.background) {
      this._settings.background = RoundedRectangle.new(this._root, {
        themeTags: mergeTags(this._settings.themeTags, ["main", "background"])
      });
    }
  }
  _makeButton() {
    return this.children.push(Button.new(this._root, {
      themeTags: ["resize", "button", this.get("orientation")],
      icon: Graphics.new(this._root, {
        themeTags: ["icon"]
      })
    }));
  }
  _makeThumb() {
    return this.children.push(RoundedRectangle.new(this._root, {
      themeTags: ["thumb", this.get("orientation")]
    }));
  }
  _handleAnimation(animation) {
    if (animation) {
      this._disposers.push(animation.events.on("stopped", () => {
        this.setPrivateRaw("isBusy", false);
        this._thumbBusy = false;
      }));
    }
  }
  _afterNew() {
    this._addOrientationClass();
    super._afterNew();
    const startGrip = this.startGrip;
    const endGrip = this.endGrip;
    const thumb = this.thumb;
    const background = this.get("background");
    if (background) {
      this._disposers.push(background.events.on("click", (event) => {
        this.setPrivateRaw("isBusy", true);
        const point = this._display.toLocal(event.point);
        const w = this.width();
        const h = this.height();
        const orientation = this.get("orientation");
        let newMiddle;
        if (orientation == "vertical") {
          newMiddle = (point.y - thumb.height() / 2) / h;
        } else {
          newMiddle = (point.x - thumb.width() / 2) / w;
        }
        let newCoordinate;
        let key;
        if (orientation == "vertical") {
          newCoordinate = newMiddle * h;
          key = "y";
        } else {
          newCoordinate = newMiddle * w;
          key = "x";
        }
        const duration = this.get("animationDuration", 0);
        if (duration > 0) {
          this._thumbBusy = true;
          this._handleAnimation(this.thumb.animate({ key, to: newCoordinate, duration, easing: this.get("animationEasing") }));
        } else {
          this.thumb.set(key, newCoordinate);
          this._root.events.once("frameended", () => {
            this.setPrivateRaw("isBusy", false);
          });
        }
      }));
    }
    this._disposers.push(thumb.events.on("dblclick", (event) => {
      if (!isLocalEvent(event.originalEvent, this)) {
        return;
      }
      const duration = this.get("animationDuration", 0);
      const easing = this.get("animationEasing");
      this.animate({ key: "start", to: 0, duration, easing });
      this.animate({ key: "end", to: 1, duration, easing });
    }));
    this._disposers.push(startGrip.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", true);
      this._startDown = true;
      this._gripDown = "start";
    }));
    this._disposers.push(endGrip.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", true);
      this._endDown = true;
      this._gripDown = "end";
    }));
    this._disposers.push(thumb.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", true);
      this._thumbDown = true;
      this._gripDown = void 0;
    }));
    this._disposers.push(startGrip.events.on("globalpointerup", () => {
      if (this._startDown) {
        this.setPrivateRaw("isBusy", false);
        this._released();
      }
      this._startDown = false;
    }));
    this._disposers.push(endGrip.events.on("globalpointerup", () => {
      if (this._endDown) {
        this.setPrivateRaw("isBusy", false);
        this._released();
      }
      this._endDown = false;
    }));
    this._disposers.push(thumb.events.on("globalpointerup", () => {
      if (this._thumbDown) {
        this.setPrivateRaw("isBusy", false);
        this._released();
      }
      this._thumbDown = false;
    }));
    this._disposers.push(startGrip.on("x", () => {
      this._updateThumb();
    }));
    this._disposers.push(endGrip.on("x", () => {
      this._updateThumb();
    }));
    this._disposers.push(startGrip.on("y", () => {
      this._updateThumb();
    }));
    this._disposers.push(endGrip.on("y", () => {
      this._updateThumb();
    }));
    this._disposers.push(thumb.events.on("positionchanged", () => {
      this._updateGripsByThumb();
    }));
    if (this.get("orientation") == "vertical") {
      startGrip.set("x", 0);
      endGrip.set("x", 0);
      this._disposers.push(thumb.adapters.add("y", (value) => {
        return Math.max(Math.min(Number(value), this.height() - thumb.height()), 0);
      }));
      this._disposers.push(thumb.adapters.add("x", (_value) => {
        return this.width() / 2;
      }));
      this._disposers.push(startGrip.adapters.add("x", (_value) => {
        return this.width() / 2;
      }));
      this._disposers.push(endGrip.adapters.add("x", (_value) => {
        return this.width() / 2;
      }));
      this._disposers.push(startGrip.adapters.add("y", (value) => {
        return Math.max(Math.min(Number(value), this.height()), 0);
      }));
      this._disposers.push(endGrip.adapters.add("y", (value) => {
        return Math.max(Math.min(Number(value), this.height()), 0);
      }));
    } else {
      startGrip.set("y", 0);
      endGrip.set("y", 0);
      this._disposers.push(thumb.adapters.add("x", (value) => {
        return Math.max(Math.min(Number(value), this.width() - thumb.width()), 0);
      }));
      this._disposers.push(thumb.adapters.add("y", (_value) => {
        return this.height() / 2;
      }));
      this._disposers.push(startGrip.adapters.add("y", (_value) => {
        return this.height() / 2;
      }));
      this._disposers.push(endGrip.adapters.add("y", (_value) => {
        return this.height() / 2;
      }));
      this._disposers.push(startGrip.adapters.add("x", (value) => {
        return Math.max(Math.min(Number(value), this.width()), 0);
      }));
      this._disposers.push(endGrip.adapters.add("x", (value) => {
        return Math.max(Math.min(Number(value), this.width()), 0);
      }));
    }
  }
  _updateChildren() {
    super._updateChildren();
    if (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) {
      this.updateGrips();
    }
  }
  _changed() {
    super._changed();
    if (this.isDirty("start") || this.isDirty("end")) {
      const eventType = "rangechanged";
      if (this.events.isEnabled(eventType)) {
        this.events.dispatch(eventType, { type: eventType, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
      }
    }
  }
  _released() {
    const eventType = "released";
    if (this.events.isEnabled(eventType)) {
      this.events.dispatch(eventType, { type: eventType, target: this });
    }
  }
  /**
   * @ignore
   */
  updateGrips() {
    const startGrip = this.startGrip;
    const endGrip = this.endGrip;
    const orientation = this.get("orientation");
    const height = this.height();
    const width = this.width();
    if (orientation == "vertical") {
      startGrip.set("y", height * this.get("start", 0));
      endGrip.set("y", height * this.get("end", 1));
    } else {
      startGrip.set("x", width * this.get("start", 0));
      endGrip.set("x", width * this.get("end", 1));
    }
    const valueFunction = this.getPrivate("positionTextFunction");
    const from = Math.round(this.get("start", 0) * 100);
    const to = Math.round(this.get("end", 0) * 100);
    let fromValue;
    let toValue;
    if (valueFunction) {
      fromValue = valueFunction.call(this, this.get("start", 0));
      toValue = valueFunction.call(this, this.get("end", 0));
    } else {
      fromValue = from + "%";
      toValue = to + "%";
    }
    startGrip.set("ariaLabel", this._t("From %1", void 0, fromValue));
    startGrip.set("ariaValueNow", "" + from);
    startGrip.set("ariaValueText", from + "%");
    startGrip.set("ariaValueMin", "0");
    startGrip.set("ariaValueMax", "100");
    endGrip.set("ariaLabel", this._t("To %1", void 0, toValue));
    endGrip.set("ariaValueNow", "" + to);
    endGrip.set("ariaValueText", to + "%");
    endGrip.set("ariaValueMin", "0");
    endGrip.set("ariaValueMax", "100");
  }
  _updateThumb() {
    const thumb = this.thumb;
    const startGrip = this.startGrip;
    const endGrip = this.endGrip;
    const height = this.height();
    const width = this.width();
    let x0 = startGrip.x();
    let x1 = endGrip.x();
    let y0 = startGrip.y();
    let y1 = endGrip.y();
    let start = 0;
    let end = 1;
    if (this.get("orientation") == "vertical") {
      if (isNumber(y0) && isNumber(y1)) {
        if (!this._thumbBusy && !thumb.isDragging()) {
          thumb.set("height", y1 - y0);
          thumb.set("y", y0);
        }
        start = y0 / height;
        end = y1 / height;
      }
    } else {
      if (isNumber(x0) && isNumber(x1)) {
        if (!this._thumbBusy && !thumb.isDragging()) {
          thumb.set("width", x1 - x0);
          thumb.set("x", x0);
        }
        start = x0 / width;
        end = x1 / width;
      }
    }
    if (this.getPrivate("isBusy") && (this.get("start") != start || this.get("end") != end)) {
      this.set("start", start);
      this.set("end", end);
    }
    const valueFunction = this.getPrivate("positionTextFunction");
    const from = Math.round(this.get("start", 0) * 100);
    const to = Math.round(this.get("end", 0) * 100);
    let fromValue;
    let toValue;
    if (valueFunction) {
      fromValue = valueFunction.call(this, this.get("start", 0));
      toValue = valueFunction.call(this, this.get("end", 0));
    } else {
      fromValue = from + "%";
      toValue = to + "%";
    }
    thumb.set("ariaLabel", this._t("From %1 to %2", void 0, fromValue, toValue));
    thumb.set("ariaValueNow", "" + from);
    thumb.set("ariaValueText", from + "%");
  }
  _updateGripsByThumb() {
    const thumb = this.thumb;
    const startGrip = this.startGrip;
    const endGrip = this.endGrip;
    if (this.get("orientation") == "vertical") {
      const thumbSize = thumb.height();
      startGrip.set("y", thumb.y());
      endGrip.set("y", thumb.y() + thumbSize);
    } else {
      const thumbSize = thumb.width();
      startGrip.set("x", thumb.x());
      endGrip.set("x", thumb.x() + thumbSize);
    }
  }
};
Scrollbar.className = "Scrollbar";
Scrollbar.classNames = Container.classNames.concat([Scrollbar.className]);

// node_modules/@amcharts/amcharts5/.internal/core/render/EditableLabel.js
var EditableLabel = class extends Label {
  _afterNew() {
    super._afterNew();
    const input = this.children.push(Container.new(this._root, {
      html: '<textarea class="am5-editable-label"></textarea>',
      isMeasured: false
    }));
    input.hide();
    this.setPrivate("input", input);
    let background = this.get("background");
    if (!background) {
      background = this.set("background", RoundedRectangle.new(this._root, {
        themeTags: ["editablelabel", "background"]
      }));
    } else {
      background.set("themeTags", ["editablelabel", "background"]);
    }
  }
  _beforeChanged() {
    super._beforeChanged();
    if (this.isDirty("editOn")) {
      if (this._editOnEvents) {
        this._editOnEvents.dispose();
      }
      const editOn = this.get("editOn", "click");
      if (editOn != "none") {
        this._editOnEvents = new MultiDisposer([
          this.getPrivate("input").events.on(editOn, (_ev) => {
          }),
          this.events.on(editOn, (_ev) => {
            this.set("active", true);
          })
        ]);
      }
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    this._maybeInitTextarea();
  }
  _updateChildren() {
    super._updateChildren();
    if (this.isDirty("active")) {
      const editing = this.get("active", false);
      if (editing) {
        this._startEditing();
      } else {
        this._stopEditing();
      }
      const bg = this.get("background");
      if (bg) {
        bg.set("active", editing);
      }
    }
    ;
    this._syncText();
    this._syncStyle();
  }
  _maybeInitTextarea() {
    if (!this._isInited()) {
      const input = this.getPrivate("input");
      if (input && input.getPrivate("htmlElement")) {
        const el = input.getPrivate("htmlElement");
        const textarea = el.querySelector(".am5-editable-label");
        if (textarea) {
          this.setPrivate("textarea", textarea);
          textarea.addEventListener("input", (_ev) => {
            if (this.get("multiLine") === false) {
              textarea.value = textarea.value.replace(/\n/g, " ");
            }
            this.set("text", textarea.value);
            this._syncStyle();
          });
          textarea.addEventListener("blur", (_ev) => this.set("active", false));
          if (supports("keyboardevents")) {
            this._disposers.push(addEventListener(document, "keydown", (ev) => {
              if (getEventKey(ev) == "Escape") {
                this.set("active", false);
              }
            }));
          }
          this._disposers.push(addEventListener(document, "keydown", (ev) => {
            if (getEventKey(ev) == "Enter" && this.get("multiLine") === false) {
              ev.preventDefault();
              this.set("active", false);
            }
          }));
          this.events.dispatch("inited", {
            type: "inited",
            target: this
          });
        }
      }
    }
  }
  _isInited() {
    return this.getPrivate("textarea") ? true : false;
  }
  _startEditing() {
    if (!this._isInited()) {
      this.events.once("inited", () => {
        this._startEditing();
      });
      return;
    }
    this._text.set("opacity", 0);
    const input = this.getPrivate("input");
    const textarea = this.getPrivate("textarea");
    if (textarea) {
      if (this.get("text", "") == "") {
        this.set("text", " ");
      }
      input.show(0);
      this.setTimeout(() => {
        this._syncStyle();
        textarea.focus();
      }, 100);
    }
  }
  _stopEditing() {
    if (!this._isInited()) {
      this.events.once("inited", () => {
        this._stopEditing();
      });
      return;
    }
    const input = this.getPrivate("input");
    const textarea = this.getPrivate("textarea");
    if (textarea) {
      this.set("text", textarea.value);
      input.hide(0);
      this._text.set("opacity", 1);
    }
  }
  _syncStyle() {
    const input = this.getPrivate("input");
    const textarea = this.getPrivate("textarea");
    const el = input.getPrivate("htmlElement");
    if (textarea && el) {
      const computedStyles = window.getComputedStyle(textarea);
      each(computedStyles, (style) => {
        textarea.style[style] = "initial";
      });
      textarea.style.color = this.get("fill", color(0)).toCSS(this.get("fillOpacity", 1));
      textarea.style.backgroundColor = "rgba(0, 0, 0, 0)";
      textarea.style.border = "none";
      textarea.style.outline = "none";
      textarea.style.padding = "0";
      textarea.wrap = "off";
      textarea.style.resize = "none";
      textarea.style.overflow = "hidden";
      const maxWidth = this.get("maxWidth", 0) - this.get("paddingLeft", 0) - this.get("paddingRight", 0);
      if (maxWidth > 0) {
        textarea.style.maxWidth = maxWidth + "px";
      } else {
        textarea.style.minWidth = "";
      }
      textarea.style.height = "auto";
      textarea.style.minHeight = textarea.scrollHeight + "px";
      if (this.get("width")) {
        textarea.style.width = this.width() - this.get("paddingLeft", 0) - this.get("paddingRight", 0) + "px";
        textarea.style.minWidth = "";
      }
      const lineHeight = this.get("lineHeight");
      if (!lineHeight) {
        textarea.style.lineHeight = "1.2";
      } else if (lineHeight instanceof Percent) {
        textarea.style.lineHeight = lineHeight.value + "";
      } else if (isNumber(lineHeight)) {
        textarea.style.lineHeight = lineHeight + "";
      }
      let fontFamily = this.get("fontFamily");
      if (!fontFamily) {
        fontFamily = getComputedStyle(el, "font-family").getPropertyValue("font-family");
      }
      textarea.style.fontFamily = fontFamily;
      let fontSize = this.get("fontSize");
      if (!fontSize) {
        fontSize = getComputedStyle(el, "font-size").getPropertyValue("font-size");
      } else if (isNumber(fontSize)) {
        fontSize = fontSize + "px";
      } else {
        fontSize = fontSize;
      }
      textarea.style.fontSize = fontSize;
      let fontWeight = this.get("fontWeight");
      if (!fontWeight) {
        fontWeight = getComputedStyle(el, "font-weight").getPropertyValue("font-weight");
      } else {
        fontWeight = fontWeight;
      }
      textarea.style.fontWeight = fontWeight;
      let fontStyle = this.get("fontStyle");
      if (!fontStyle) {
        fontStyle = getComputedStyle(el, "font-style").getPropertyValue("font-style");
      } else {
        fontStyle = fontStyle;
      }
      textarea.style.fontStyle = fontStyle;
      const oversizeBehavior = this.get("oversizedBehavior");
      if (oversizeBehavior == "wrap") {
        textarea.style.whiteSpace = "pre-wrap";
      } else {
        textarea.style.whiteSpace = "nowrap";
      }
      this._root.events.on("frameended", () => {
        if (textarea.style.minWidth == "") {
          textarea.style.minWidth = textarea.scrollWidth + 20 + "px";
        }
        const textAlign = this.get("textAlign", "start");
        if (textAlign == "center") {
          textarea.style.textAlign = "center";
          if (!el.style.transform.match(/translateX/) && !this.get("width")) {
            el.style.transform += " translateX(-50%)";
          }
        } else if (textAlign == "end") {
          textarea.style.textAlign = "right";
          if (!el.style.transform.match(/translateX/) && !this.get("width")) {
            el.style.transform += " translateX(-100%)";
          }
        } else {
          textarea.style.textAlign = textAlign;
        }
      });
    }
  }
  _syncText() {
    const textarea = this.getPrivate("textarea");
    let text = this.get("text", "");
    if (text == " ") {
      text = "";
    }
    if (textarea) {
      textarea.value = text;
    }
  }
};
EditableLabel.className = "EditableLabel";
EditableLabel.classNames = Label.classNames.concat([EditableLabel.className]);

export {
  RoundedRectangle,
  Button,
  Scrollbar,
  EditableLabel
};
//# sourceMappingURL=chunk-BGNUVQCU.js.map
